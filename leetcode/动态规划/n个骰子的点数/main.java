package n个骰子的点数;
/* 
 * 
“题目描述 ：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

难度：中等

示例 1:

输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
复制
示例 2:

输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
 */

//对于n个骰子有6^n种组合
//s的取值范围为[n-6n]
//对于和为8的情况有k种组合，那么概率就是k/6^n,暴力法的时间复杂度是6^n的，很大
public class main {
    //定义dp数组含义，dp[i][j]表示当骰子个数为i，点数和为j时，它们的组合数为dp[i][j]
    //求概率则dp[i][j]/6^n;
    //确定dp公式，要想从dp[i-1][j-1]到dp[i][j],相当于多了一个骰子，那这个骰子可能值是1～6，所以要把这六种可能性全部加上
    //dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + …… + dp[i-1][j-6];
    public double[] statisticsProbability(int num) {
        int[][] dp = new int[num+1][6*num+1];
        for (int j = 1; j <= 6; j++) {
            dp[1][j] = 1; // 边界条件
        }
        for (int i = 2; i <= num; i++) {  // 投掷第 2 到第 n 个骰子
            for (int j = i; j <= 6*i; j++) {  // 投掷第 i 个骰子时出现的点数之和的范围
                for (int k = 1; k <= 6; k++) { //第 n 枚骰子，它的点数可能为 1 , 2, 3, ... , 6，因此投掷完 n 枚骰子后点数 j 出现的次数，可以由投掷完 n-1 枚骰子后，对应点数 j-1, j-2, j-3, ... , j-6出现的次数之和转化过来。
                    //防止越界
                    if(j < k){
                        break;
                    }
                    dp[i][j] += dp[i-1][j-k];
                }
            }
        }
        //因为取值范围（n~6n),所以是6n-n+1
        double[] res = new double[5*num+1];
        int index = 0;
        double sum = Math.pow(6, num);  //总次数
        for (int i = num; i <= 6*num; i++) {
            res[index++] = dp[num][i]/sum;      
        }
        return res;
    }
}
