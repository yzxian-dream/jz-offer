package 把数字翻译成字符串;
/* 
 * 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。
 * 一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

 

示例 1:

输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
 */
public class main {
    //dp[i]表示当数组的长度为i时，一共有dp[i]个方案,类似于上楼梯，
    //当数组第i位单独成一个字母是不需要组合的，那就有dp[i-1]个方案
    //当数组第i位要和第i-1位组合成字母时（组合的值10<=tmp<=25），就有dp[i-2]+dp[i-1]个方案
    //以上就是dp公式
/* 
 * 就跟经典的上楼梯一样（可以一次一阶，也可以一次两阶），我们可以一个一个解码，也可以两个两个，唯一的不同在于需要判断可不可以两个一起解码（即[10,25]之间）。所以转移方程为：

dp[i] = dp[i-1] + dp[i-2] （满足条件）

dp[i] = dp[i-1] （不满足两位一起解码条件）

再考虑初始条件，dp[0] = 1，dp[1] = 1/2（判断前两个数符不符合条件）即可。

最后返回dp[n-1]。

复杂度分析
遍历一次数转换成的字符串，时间复杂度为O(N)
使用一个额外的数组，空间复杂度O(N)，但是由于dp[i]只与dp[i-1]和dp[i-2]有关，实际可以用几个变量将复杂度降到O(1)，但是本题取值范围限制为32位（二进制），所以实际上数组长度很短，没必要
 */
    public int translateNum(int num) {
        char[] charArray = String.valueOf(num).toCharArray();
        int[] dp = new int[charArray.length+1];
        if (num<=9) {
            return 1;
        }
        dp[0] = 1;
        dp[1] = 1;
        //这里for循环要charArray.lengt+1，不然最后一个值取不到，因为i-1.
        for (int i = 2; i < charArray.length+1; i++) {
            //长度为i时当前值为charArray[i-1]
            int tmp = 10 * (charArray[i-2]-'0') + (charArray[i-1]-'0');
            //紧挨着的两个字符拼接在一起，如果如果在0-26之间，就是a-z，就可以有两种情况，否则就是一种情况，先对于-1的长度的字符串的种类不变，并没有加一
            if (tmp >= 10 && tmp <= 25) {
                dp[i] = dp[i-1]+dp[i-2];
            }else{
                dp[i] = dp[i-1];
            }
        }
        return dp[charArray.length];
        
    }
}
